<!doctype html><html lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <title>Progressive Font Enrichment: Evaluation Report</title>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
    <link href="#fixme" rel="canonical"/>
    <link rel="stylesheet" href="css/main.css"/>
    <link rel="stylesheet"  href="https://www.w3.org/StyleSheets/TR/2016/W3C-WG-NOTE"/>
 <body class="h-entry">
  <div class="head">
   <p data-fill-with="logo"><a class="logo" href="https://www.w3.org/"> <img alt="W3C" height="48" src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" width="72"> </a> </p>
   <h1>Progressive Font Enrichment: <br>Evaluation Report</h1>
   <h2 class="no-num no-toc no-ref heading settled" id="subtitle"><span class="content">W3C Working Group Note, 14 September 2020</span></h2>
   <div data-fill-with="spec-metadata">
    <dl>
     <dt>This version:
     <dd><a class="u-url" href="">https://www.w3.org/TR/<span class="todo">todo</span></a>
     <dt>Latest published version:
     <dd><a href="https://www.w3.org/TR/">https://www.w3.org/TR/<span class="todo">todo</span></a>
     <dt>Editor's Draft:
     <dd><a href="https://w3c.github.io/PFE-analysis/report/evaluation-report.html">https://w3c.github.io/PFE-analysis/report/evaluation-report.html</a>
     <!-- <dt>Previous Versions:
     <dd> -->
     <dt>Issue Tracking:
     <dd><a href="https://github.com/w3c/PFE-analysis/issues">GitHub</a>
     <dt class="editor">Editor:
     <dd class="editor p-author h-card vcard" data-editor-id="1438"><a class="p-name fn u-email email" href="mailto:chris@w3.org">Chris Lilley</a> (<a class="p-org org" href="https://w3.org">W3C</a>)
    </dl>
   </div>
   <div data-fill-with="warning"></div>

   <p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2020 <a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="https://www.keio.ac.jp/">Keio</a>, <a href="https://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>

   <hr title="Separator for header">
  </div>
  <div class="p-summary" data-fill-with="abstract">
   <h2 class="no-num no-toc no-ref heading settled" id="abstract"><span class="content">Abstract</span></h2>
   <p>The success of WebFonts is unevenly distributed.
    This study evaluates solutions
    which would allow WebFonts to be used
    where slow networks,
    very large fonts,
    or complex subsetting requirements
    currently preclude their use.</p>
  </div>

  <!--

    AC Oct 20 -> 12-16

    why a sigmoid function?

    where does -11.5 come from in cost function
    why are Tz and Tm divided by two

    cost reduction maxes at 100%

    where do the "real page walks" page views and page view sequences come from
    anonymyzed aggregated google staff page views?
    not specific to google fonts
    chrome
    walk of urls
    contents of urls
    codepoints per font-face
    sub in fonts to google fonts
    "100% webfont" model
    further work use non-Google fonts too.
    glyph repertoire similar for other fonts.
    study with Monotype fonts though
    https://lists.w3.org/Archives/Public/public-webfonts-wg/2020May/0001.html
    what are "adobe data set sequences"?
    aha
    https://lists.w3.org/Archives/Public/public-webfonts-wg/2020Apr/0005.html
    compared to the adobe ethod

    normally google removed opentype features, hints, etc to minimize filesize
    sim did not do that
    but
    "fonts included have been preprocessed
    to remove hinting and variation data"
    https://lists.w3.org/Archives/Public/public-webfonts-wg/2020Sep/0007.html


    why not subsample English more and the other simple languages less?
    Same for Arabic and Japanese
    Langauage list for the "too small" slices on each pie?
    Distribution of langauges retained.



  -->

  <section id="sotd" class="introductory"><h2 id="h-sotd" resource="#h-sotd"><span property="xhv:role" resource="xhv:heading">Status of This Document</span></h2>

        <p>
          <em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current <abbr title="World Wide Web Consortium">W3C</abbr> publications and the latest revision of this technical report can be found in the <a href="https://www.w3.org/TR/"><abbr title="World Wide Web Consortium">W3C</abbr> technical reports index</a> at https://www.w3.org/TR/.</em>
        </p>

        <p>
            This is an (a draft) Evaluation Report
as <a href="https://www.w3.org/Fonts/WG/webfonts-2018.html#ig-other-deliverables">required
    by the charter</a> of the
WebFonts Working Group.
It has not yet been reviewed or approved by that group.
It will eventually be presented to the public
as a report on the investigative activities undertaken
during 2019 and 2020,
prior to standardization work.
        </p>

          <p>
            This document was <em>(will be)</em> published by the <a href="https://www.w3.org/Fonts/WG/">WebFonts Working Group</a> as a Working Group Note.<br>

              Please raise issues on this document on <a href="https://github.com/w3c/PFE-analysis/issues">GitHub</a>. All comments are welcome.
          </p>

            <p>
              Publication as a Working Group Note does not imply endorsement by the <abbr title="World Wide Web Consortium">W3C</abbr>
              Membership. This is a draft document and may be updated, replaced or obsoleted by other
              documents at any time. It is inappropriate to cite this document as other than work in
              progress.
            </p>


<p data-deliverer="44556">This document was produced by a group operating under the <a href="https://www.w3.org/Consortium/Patent-Policy/">W3C Patent Policy</a>.</p>
   <p>This document is governed by the <a href="https://www.w3.org/2019/Process-20190301/" id="w3c_process_revision">1 March 2019 W3C Process Document</a>.</p>


</section>

  <nav data-fill-with="table-of-contents" id="toc">
   <h2 class="no-num no-toc no-ref todo" id="contents">Table of Contents</h2>
   <ol class="toc" role="directory">
    <li>
     <a href="#intro"><span class="secno">1</span> <span class="content"> Introduction</span></a></li>

    <li>
     <a href="#deployment"><span class="secno">2</span> <span class="content"> Webfont deployment - successes, problems, solutions</span></a>
     <ol class="toc">
      <li><a href="#fontface"><span class="secno">2.1</span> <span class="content"> @font-face</span></a>
      <li><a href="#common"><span class="secno">2.2</span> <span class="content"> Common font format</span></a>
      <li><a href="#WOFF1"><span class="secno">2.3</span> <span class="content"> WOFF 1.0</span></a>
      <li><a href="#WOFF2"><span class="secno">2.4</span> <span class="content"> WOFF 2.0</span></a>
      <li><a href="#static"><span class="secno">2.5</span> <span class="content"> Static subsets and unicode-range</span></a>
      <li><a href="#success-simple"><span class="secno">2.6</span> <span class="content"> Success: Widespread success for simple fonts</span></a>
      <li><a href="#fail-large"><span class="secno">2.7</span> <span class="content"> Failure: Large glyph repertoires</span></a>
      <li><a href="#sfail-subset"><span class="secno">2.8</span> <span class="content"> Failure: Difficulty with subsetting</span></a>
      <li><a href="#soln-PFE"><span class="secno">2.9</span> <span class="content"> Solution: Progressive Font Enrichment</span></a>

     </ol>
     <li>
      <a href="#design"><span class="secno">3</span> <span class="content">Initial trials</span></a>
    <li>
     <a href="#design"><span class="secno">4</span> <span class="content">Study design</span></a>
     <ol class="toc">
      <li><a href="#criteria"><span class="secno">4.1</span> <span class="content"> Success criteria</span></a>
      <li><a href="#servtype"><span class="secno">4.2</span> <span class="content"> Server type: intelligent vs. simple</span></a>
        <ol class="toc">
          <li><a href="#patch-subset"><span class="secno">4.2.1</span> <span class="content"> Patch and Subset</span></a>
            <li><a href="#glyph-byterange"><span class="secno">4.2.2</span> <span class="content"> Glyph Byterange</span></a>
        </ol>
      <li><a href="#cost"><span class="secno">4.3</span> <span class="content"> Cost function</span></a>
      <li><a href="#network"><span class="secno">4.4</span> <span class="content"> Network type - slow 2G to fast broadband</span></a>
      <li><a href="#langtype"><span class="secno">4.5</span> <span class="content"> Language type: small &amp; simple, complex shaping, large</span></a>
      <li><a href="#codepredict"><span class="secno">4.6</span> <span class="content"> Codepoint Prediction</span></a>
      <!-- <li><a href="#group"><span class="secno">4.7</span> <span class="content"> Byterange subsetting: glyph grouping</span></a> -->
      <li><a href="#framework"><span class="secno">4.7</span> <span class="content"> Simulation and analysis framework</span></a>
      <li><a href="#oos"><span class="secno">4.8</span> <span class="content"> Out of scope</span></a>
     </ol>

    <li>
     <a href="#analysis"><span class="secno">5</span> <span class="content"> Analysis </span></a>
     <ol class="toc">
      <li><a href="#codepredictresult"><span class="secno">5.x</span> <span class="content"> Effect of Codepoint Prediction</span></a>
     </ol>

    <li><a href="#conclusions"><span class="secno">6</span> <span class="content"> Conclusions</span></a>
    <li>
     <a href="#references"><span class="secno">A</span> <span class="content"> References</span></a>

   </ol>
  </nav>
  <main>
   <section>
    <h2 class="heading settled" data-level="1" id="intro"><span class="secno">1. </span><span class="content">Introduction</span><a class="self-link" href="#intro"></a></h2>

    <!-- terminology - character, glyph, font -->
    <p>The success of WebFonts is widespread (80%, globally)
        but unevenly distributed.
        In certain areas of the world, usage is <em>zero</em>.
        This study evaluates solutions
        which would allow WebFonts to be used
        where slow networks,
        very large fonts,
        or complex subsetting requirements
        currently preclude their use.</p>
   </section>

   <section>
    <h2 class="heading settled" data-level="1" id="deployment"><span class="secno">2. </span><span class="content">Webfont deployment - successes, problems, solutions</span><a class="self-link" href="#deployment"></a></h2>
    <p>
        This section examines the historical deployment of Webfonts
        from their inception in 1997 to date.
        The reasons for the success in deployment are described.
        Then, problems which prevented further deployment are examined.
        Lastly, potential solutions are briefly introduced.
        The detailed evaluation of these solutions comprises the majorty of this report.
    </p>

    <section>
        <h3 class="heading settled" data-level="2" id="fontface"><span class="secno">2.1 </span><span class="content">@font-face</span><a class="self-link" href="#fontface"></a></h3>
        <p>
            Initially introduced in 1997 [<a href="#ref-webfonts">WebFonts</a>]
            and later integrated into CSS2 [<a href="#ref-CSS2">CSS2</a>]
            and SVG1 [<a href="#ref-SVG1">SVG1</a>],
            the CSS <span class="code">@font-face</span>
            allows for the automatic fetching of a font,
            on demand as the stylesheet is used to render a document,
            without user intervention.
            The font is used immediately, without being installed onto the system.
        </p>
        <p>
            This technology was a necessary but not sufficient requirement for deployment.
            At the time, no consensus could be found on a
            single interoperable WebFont format,
            nor on a way to automatically convey licensing and other IPR information.
            Thus, early implementations each used their own format:
        </p>
        <ul>
            <li>Embedded OpenType™(MS Internet Explorer 3)</li>
            <li>Portable Font Resources (Netscape Navigator 4/Bitstream)</li>
            <li>SVG Fonts (pre-smartphone SVG implementations)</li>
        </ul>
        <p>
            Due to lack of interoperability,
            plus other technical drawbacks of the initial font formats used,
            when in 2002 CSS 2.1 [<a href="#ref-CSS21-fpwd">CSS21 FPWD</a>] was developed as the "core, interoperable subset" of CSS2,
            <span class="code">@font-face</span>
             was dropped from the specification [<a href="#ref-CSS21">CSS21</a>].</p>

            <p>It was only added back to CSS with CSS3 WebFonts [<a href="#ref-css3-webfonts">CSS3 WebFonts</a>], which was merged into
            the First Public Working Draft of CSS Fonts 3 in 2011 [<a href="#ref-css-fonts-3-fpwd">CSS Fonts 3 FPWD</a> ]
            CSS Fonts 3
        </p>
       </section>

       <section>
        <h3 class="heading settled" data-level="2" id="common"><span class="secno">2.2 </span><span class="content">Common font format</span><a class="self-link" href="#fontface"></a></h3>

        <p>
          The first attempts to use fonts on the web reflected the plethora of font formats in use on computers at the time. In 2002 the [<a href="#ref-css3-webfonts">CSS3 WebFonts</a>] specification
          <a href="https://www.w3.org/TR/2002/WD-css3-webfonts-20020802/#referencing">noted an "initial" list</a>
          of eight different font formats
          <q>representing formats likely to be used by implementations on various platforms </q>
        </p>
        <ul>
          <li>TrueDoc™ Portable Font Resource (Bitstream)</li>
          <li>Embedded OpenType™(Microsoft)</li>
          <li>PostScript™ Type 1 (Adobe)</li>
          <li>TrueType™ (Apple)</li>
          <li>OpenType™, including TrueType Open (Microsoft></li>
          <li>TrueType™ with GX extensions (Apple)</li>
          <li>Speedo™ (Bitstream)</li>
          <li>Intellifont (Compugraphic)</li>
        </ul>
        <p>
          (and this was without mentioning the many bitmapped formats still in common use at the time; of the SVG font format which came later).
        </p>
        <p>Over time OpenType™ [<a href="#ref-OpenType">OpenType</a>],
          which uses TrueType™ outlines
          and can also include Type 1 outlines (as CFF)
          and SVG outlines,
          and was then expanded to include
          chromatic fonts and the GX-like variable fonts,
          became the dominant format in use.
          It was eventually standardized by ISO as Open Font Format [<a href="#ref-OFF">OFF</a>],
          the name change caused by the trademark on the name OpenType™.
        </p>
        <p>
          OpenType™ has a tabular structure, each table holding a particular type of information. For example
          the <span class="sfnt">cmap</span> tabe holds character map information,
          the <span class="sfnt">hhea</span> and <span class="sfnt">OS/2</span>
          tables hold glyph metrics,
          kerning information is stored in the
          <span class="sfnt">GPOS</span> or <span class="sfnt">kern</span>
          tables, while the actual glyph outlines
          are in the <span class="sfnt">glyf</span>,
          <span class="sfnt">CFF</span>, <span class="sfnt">CFF2</span>
          or <span class="sfnt">SVG</span> tables.
        </p>
        <figure>
          <figcaption>Some of the OpenType™ font tables which make up a practical font.</figcaption>
          <img src="images/sfnt.svg" alt="" style="max-width: 15%">
        </figure>
        <p id="scattered">
          In consequence, the total information needed to render a single glyph
          is scattered throughout many tables in an OpenType™ font.
          This has consequences for font subsetting,
          and foils attempts to use simple video-like streaming,
          as we will see later.
        </p>
       </section>

       <section>
        <h3 class="heading settled" data-level="2" id="WOFF1"><span class="secno">2.3 </span><span class="content">WOFF 1.0</span><a class="self-link" href="#WOFF1"></a></h3>
        <p>
            Developed between 2010 and 2012, WOFF 1.0 [<a href="#ref-WOFF1">WOFF1</a>]is a Web delivery format for OpenType.
            It compresses each OpenType™ table separately with gzip,
            and adds optional metadata which can, for example,
            include a link to the license for that font.
            Notably, the user agent is not expected to
            (indeed, is <em><a href="https://www.w3.org/TR/2012/REC-WOFF-20121213/#conform-metadata-noeffect">specifically forbidden from</a></em>)
            behaving differently based on the presence, absence, or contents of such metadata.
            This allayed concernes by browser vendors
            that they would be required to police font usage;
            and allayed concerns from font vendors that font data
            would be forever separated from its licensing metadata.
        </p>
        <figure>
          <figcaption>Compression of font tables (left) in WOFF 1.0 (right). A header, a directory of compressed tables, and optional metadata and private data are added.</figcaption>
          <img src="images/sfnt-woff1.svg" alt="" style="max-width: 80%">
        </figure>

        <p>
            By using a lightweight compression scheme which already existed in browsers
            (gzip, used in the PNG image format and also for HTTP compression),
            implementation burden was lessened.
            By offering bit-for-bit lossless compression,
            concerns over "approximate" fonts
            (which had, for example, affected the PFR format)
            were also allayed.
        </p>
        <p>
            By providing an agreed interoperable font format for download,
            which met the requirements of both type vendors and browser vendors,
            WOFF 1.0 was responsible for taking global WebFont usage
            <strong>from 0.1% in 2006 to 35% in 2014</strong> <span class="todo">[add ref]</span>.
        </p>
       </section>

       <section>
        <h3 class="heading settled" data-level="2" id="WOFF2"><span class="secno">2.4 </span><span class="content">WOFF 2.0</span><a class="self-link" href="#WOFF2"></a></h3>

        <p>Developed between 2014 and 2018, WOFF 2.0 [<a href="#ref-WOFF2">WOFF2</a>],
            significantly improves over WOFF 1.0
            by using a font-specific preprocessing step
            followed by Brotli compression.
        </p>
        <p>
            Once WOFF 1.0 had paved the way by demonstrating the utility of WebFonts,
            it was possible to put in place a more complex, but more space efficient
            two-part compression scheme. As the volume of font data worldwide was increasing,
            this was seen as a high priority.
            As it was demonstrated [WOFF2-ER]
            that WOFF 2.0 would never give a worse compression result than WOFF 1.0,
            WOFF 2.0 rapidly became supported by all browsers
            and has taken over from WOFF 1.0.
        </p>
        <figure>
          <figcaption>Compression of font tables (left) in WOFF 2.0 (right). Data in the tables is made smaller, redundant data removed, and in some cases a table is entirely ommitted (to be rebuild on decompression). A header, a directory of compressed tables, and optional collection information, metadata and private data are added.</figcaption>
          <img src="images/sfnt-woff2.svg" alt="" style="max-width: 80%">
        </figure>

        <p>
            Global webfont usage is <strong>now over 80%</strong>.
        </p>

        <figure>
            <figcaption>Growth in global WebFonts usage from near-zero in 2011 to 80% in 2020 [<a href="#ref-Sheeter-BigQuery">Sheeter BigQuery</a>]</figcaption>
            <img src="images/2020-07-22_Web_Font_Usage.png" alt="">
        </figure>
       </section>

       <section>
        <h3 class="heading settled" data-level="2" id="static"><span class="secno">2.5 </span><span class="content">Static subsets and unicode-range</span><a class="self-link" href="#static"></a></h3>

        <p>
            CSS has a feature, unicode-range [<a href="#ref-unicode-range">UNICODE-RANGE</a>],
            which states which characters a font *doesn't* have glyphs for.
            This prevents a webfont being needlessly downloaded.

            Combined with static subsetting,
            this greatly reduces the volume of font data for common, monolingual websites.
        </p>
        <p>
            For example, a font which supports Latin, Greek, and Cyrillic
            can be split into three subsets;
            typically only one will be downloaded.
            Google Fonts uses this approach extensively
            [<a href="#ref-Google-scrpt-subsets">Google script subsets</a>],
            and it works well for languages which use only a small number of glyphs.
        </p>

        <p id="target">
            This study assumes that the <em>target to beat</em> is
            a static subset font,
            with glyph coverage for only the characters actually used,
            compressed with the best available method, WOFF 2.0.
        </p>
       </section>

       <section>
        <h3 class="heading settled" data-level="2" id="success-simple"><span class="secno">2.6 </span><span class="content">Success: Widespread success for simple fonts</span><a class="self-link" href="#success-simple"></a></h3>

        <p>
            Websites with content languages using the Latin alphabet
            (such as Vietnamese, most European and Africal languages),
            Greek and Cyrillic alphabets,
            and Thai all make modest demands on fonts.
            The number of unique characters is limited,
            typically under a hundred;
            contextual shaping is rare to non-existent,
            and thus fonts are easy to subset and compressed font sizes are very small.
        </p>
       </section>

       <section>
        <h3 class="heading settled" data-level="2" id="fail-large"><span class="secno">2.7 </span><span class="content">Failure: Large glyph repertoires</span><a class="self-link" href="#fail-large"></a></h3>

        <p>
            Languages such as Chinese, Japanese, and Korean
            have many thousands of characters.
            For example, the Zhonghua Zihai (simplified Chinese: 中华字海; traditional Chinese: 中華字海) lists 85,568 Chinese characters.
            The Hangul Syllables block in Unicode
            lists 11,172 precomposed Hangul syllable blocks for modern Korean.
            Font data is thus massive.
            While there is statistical variation in usage from character to character,
            it is not in general possible to statically subset fonts into
            "always used" and "never used" subsets;
            the size of the "sometimes used" group predominates.
        </p>
        <!-- reference dictionary sizes
          https://en.wikipedia.org/wiki/Zhonghua_Zihai#Other_dictionaries
        -->
        <p>
            Static subsetting is unusable,
            font sizes are in the megabytes,
            and mobile Web usage is significant.
        </p>
        <p>
            A 2019 study by the HTTP Archive
            found that the median number of bytes
            used for Web Fonts on websites in China
            was <strong>zero</strong>.
            <span>[<a href="#ref-Web-Almanac-2019-Fonts">Web Almanac 2019: Fonts</a>]</span>
            <!--
              Map from
              https://discuss.httparchive.org/t/how-does-web-font-usage-vary-by-country/1649/9
             -->
        </p>

        <figure>
            <figcaption>Usage of webfonts for CJK languages is close to zero</figcaption>
            <img src="images/httparchive-china-zero.png" alt="china zero webfonts">
        </figure>

        <p>
          Pan-Unicode fonts
          (fonts which aim to cover a very large number of languages)
          can be difficult to subset
          and, if subsetted,
          the functionality can be reduced.
          For example, due to size, the Noto family
          is currently served as a bunch of separate families.
          It is up to the developer to explicitly
          pick which ones they might need.
        </p>
        <p>
          Static subsets
          where each subset appears to have a distinct
          <em>font family name</em>
          are also more difficult to use
          when creating truly multilingual websites.
          For example, a discussion forum
          may have users posting
          in a variety of languages.
          A global mapping application
          will need to render text in a wide array of scripts,
          depending on what part of the world is being viewed.
          In both cases, the range of supported languages
          is wide, and may change as the content is updated.
        </p>

       </section>

       <section>
        <h3 class="heading settled" data-level="2" id="fail-subset"><span class="secno">2.8 </span><span class="content">Failure: Difficulty with subsetting</span><a class="self-link" href="#fail-subset"></a></h3>

        <p>Static subsetting can run into difficulties when there are complex inter-relationships between different OpenType™tables, or when characgters are shared between multiple scripts but behave differently in each script.</p>

        <p>
          To take a simple example, both Latin and Cyrillic scripts use the period (<b>.</b>) at the end of a sentence. Because Latin-only or Cyrillic-only content is common, splitting a font that covers both Latin and Cyrillic into two smaller static subsets makes sense. However, if content uses Cyrillic text and also uses the period  from the Latin subset, then kerning rules between the Cyrllic characters and the period no longer work, whereas they did in the original font which contained the complete kerning information.
        </p>

        <figure>
          <figcaption>Broken kerning due to font subsetting
            (Latin subset in green, Cyrillic subset in blue;
            both subsets include common punctuation).
          </figcaption>
          <img src="images/kern.png" alt="" style="max-width:40vw">
        </figure>

        <p>
          Some background for a more complex example:
          India has large linguistic diversity,
          with 22 constitutionally recognized languages
          and 12 distinct scripts [<a href="#ref-IndicLR">IndicLR</a>].
          In some scripts, there are complex glyph shaping needs
          [<a href="#ref-Indic-Intro">Indic-Intro</a>].
          For example a Matra (dependent vowel) can be placed above, below,
          or be split, part before and part after a consonant.</p>

          <figure>
            <figcaption>Examples of glyph shaping in Bengali</figcaption>
            <img src="images/Bengali-shaping.png" alt="" style="max-width: 70%">
          </figure>

          <p>There are also some shared characters between the scripts.
          If a font supports two or more of these scripts,
          which is common,
          and the content developer wants to present it as a single font family
          and use unicode range to deliver per-script subsets,
          the shared characters need to be duplicated in each subset.
          Not only does this mean that the total size of all subsets
          is greater than the original font,
          but also
          the shared characters will be rendered from only one of the subsets
          based on the priority of the unicode range declarations.
          As a result syllable clustering and glyph shaping doesn't work correctly;
          the text doesn't just look <em>less beautiful</em>, it becomes <strong>unreadable</strong>.
        </p>

        <!-- <p class="todo">add illustration of correct and incorrect rendering</p> -->

        <!-- <p class="note">No mention in <a href="https://www.w3.org/TR/international-specs/">Internationalization Best Practices for Spec Developers</a>. Related <a href="https://lists.w3.org/Archives/Public/public-i18n-core/2018AprJun/0042.html">I18N-ACTION-721: Look into font subsetting for charmod-norm</a> but no mention in <a href="https://www.w3.org/TR/charmod-norm/">Character Model for the World Wide Web: String Matching</a>.</p> -->

       </section>

       <section>
        <h3 class="heading settled" data-level="2" id="soln-PFE"><span class="secno">2.9 </span><span class="content">Solution: Progressive Font Enrichment</span><a class="self-link" href="#soln-PFE"></a></h3>

        <p>
            Instead of downloading a static subset
            (or, where static subsetting cannt work, downloading an entire font),
            this proposed solution uses a continuous process of dynamic subsetting.
            A small subsetted font is downloaded,
            which can display the content currently being browsed.
            As the user moves on to other content,
            (or as content is added - for example on user forums or with commenting systems)
            additional data for that font is automatically downloaded
            and the font becomes <em>progressively enriched</em> over time.
            In contrast to fine-grained static subsetting,
            the CSS remains simple
            because the stylesheet sees only a single font,
            not a plethora of related fonts.
        </p>
        <p>
          This helps with single-language fonts for languages such as Chinese,
          and simplifies robust deployment of pan-Unicode fonts.
          It avoids kerning and shaping breakage for comlex scripts.
        </p>
        <p>
            While this approach has been deployed experimentally
            by several font foundries (
            Adobe TypeKit,
            Monotype,
            Google Fonts
            ),
            it is desirable for interoperability
            that a standardized solution for Progressive Font Enrichment (PFE) exists.
        </p>
        <p>
            To ensure that the correct solution is standardized,
            which works with a variety of network conditions
            and content languages,
            the W3C WebFonts Working group was chartered
            to explore the area
            and to run simulation experiments on the proposed solution space
            before undertaking standards-track work.
        </p>

   </section>

   <section>
    <h2 class="heading settled" data-level="1" id="design"><span class="secno">3. </span><span class="content">Initial trials</span><a class="self-link" href="#trials"></a></h2>

    <p>
      Adobe has already deployed a proprietary form of progressive font enrichment.
      Performance data from that solution was compared with
      an early prototype of the <strong>Patch Subset</strong> method
      (<a href="">described below</a>).
      In this initial trial,
      these were both compared to
      a theoretical <strong>optimal</strong> method
      (a static subset containing <em>exactly</em>
      the glyphs needed for a given page sequence).
    </p>

    <p>
      These simulations used exclusively CJK fonts,
      primarily the Source Han Sans/Serif or Noto
      Sans/Serif CJK collections.
      All of the CFF fonts were de-subroutnized
      before being used in the simulation.
      This produced the lowest overall transfer sizes.
    </p>

    <p>
      Both <strong>Adobe's solution</strong> and <strong>Patch and Subset</strong>
      deliver close to optimal results on number of bytes transferred,
      with <strong>Patch and Subset</strong> transferring an additional 19%,
      and <strong>Adobe's solution</strong> an additional 45%,
      versus the theoretical optimal transfer bytes.
    </p>

    <p>
      The test was repeated, but this time using
      fonts provided by Monotype.
      The results were similar,
      except that <strong>Patch and Subset</strong>
      transferred an additional 65%
      versus the theoretical optimal transfer bytes.
    </p>

    <p>
      It became clear from both trials that network bandwidth, although important,
      was not the limiting factor for performance.
      Rather, the <strong>network latency</strong>
      (overall round-trip time for a single request)
      was the important variable.
      This is because a font is delivered in response to several requests over time,
      rather than in one big request and response.
      This finding informed the study design.
    </p>
   </section>


   <section>
    <h2 class="heading settled" data-level="1" id="design"><span class="secno">4. </span><span class="content">Study Design</span><a class="self-link" href="#design"></a></h2>

    <section>
      <h3 class="heading settled" data-level="2" id="criteria"><span class="secno">4.1 </span><span class="content">Success criteria</span><a class="self-link" href="#criteria"></a></h3>

    <!--
      Thoughts on how to Summarize Simulation Results
      https://lists.w3.org/Archives/Public/public-webfonts-wg/2020Sep/0003.html
    -->

    <p>The following success criteria were taken into account. A good Progressive Font Enrichment solution will:</p>

    <ul>
      <li>Retain all <em>layout rules</em> found in the source font,
        which are needed for the codepoints present on a particular page.</li>
      <li>Load font data <em>fairly</em>, that is for each page view the amount of font data loaded is related to the number of new codepoints on that page.</li>
      <li>Minimize the <em>user perceptible delay</em> caused by font loading.</li>
      <li>Have good <em>network performance</em>, that is it minimizes:
        <ul>
          <li>The worst case network delay caused by font loading for clients when viewing a sequence of pages.</li>
          <li>The total number of bytes transferred (both requests and responses) caused by font loading for clients when viewing a sequence of pages.</li>
          <li>the total number of network requests caused by font loading for clients when viewing a sequence of pages.</li>
        </ul>
      </li>
    </ul>

    </section>

    <section>
      <h3 class="heading settled" data-level="2" id="servtype"><span class="secno">4.2 </span><span class="content">Server type: intelligent vs. simple</span><a class="self-link" href="#servtype"></a></h3>

    <p>
        Two entirely different types of font enrichment have been studied.
        They differ in the demands made of the server which serves the fonts
        (both approaches require client support).
        One requires an active server extension.
        The other requires only a standard Web server, so could be deployed anywhere.
        They make differing tradeoffs and have correspondingly different advantages and disadvantages.
    </p>

    <section>
      <h4 class="heading settled" data-level="3" id="patch-subset"><span class="secno">4.2.1 </span><span class="content">Patch and Subset</span><a class="self-link" href="#patch-subset"></a></h4>
    <p >
        In one approach, <strong>Patch and Subset</strong>,
        the entire font is dynamically subsetted on the server.
        The client and the server communicate closely
        to generate the optimal set of enrichment glyphs
        and other font information
        with each transaction.
    </p>

    <p>
      The first response is a standalone OpenType font,
      (served over HTTP/2, and with Brotli Content Transfer Encoding)
      containing <em>only</em> the data (glyphs and metrics)
      required to render the specific codepoints requested.
      This means that every OpenType table
      has been dynamically subsetted on the server,
      to produce this response.
    </p>

    <p>
      For subsequent responses,
      a Brotli binary patch is used to update the font stored on the client.
      (Generating these patches, and applying them,
      are both features of the standard Brotli library).
      The patches make use of the Brotli compression dictionary
      created to serve the initial font,
      and thus the cost of an duplicated data is greatly reduced.
      This approach tends more closely towards
      the theoretical peak efficiency
      in terms of bytes transfered
      and minimal network latency,
      but requires an intelligent server
      which can subset all OpenType tables,
      without breaking layout,
      retain the compression dictionary,
      and woff-compress the font on the fly.
      This approach also allows parameters to be tuned
      to maximize efficiency
      based on the current network conditions.
    </p>
    </section>

    <section>
      <h4 class="heading settled" data-level="3" id="glyph-byterange"><span class="secno">4.2.2 </span><span class="content">Glyph Byterange</span><a class="self-link" href="#glyph-byterange"></a></h4>

      <p>
        In the second approach, <strong>Glyph Byterange</strong>,
        a streaming approach similar to video streaming is used.
        Again, an OpenType font is
        served (over HTTP/2, and with Brotli Content Transfer Encoding).
        As <a href="#scattered">previously mentioned</a>,
        information required for a given glyph is scattered throughout the font.
        Thus, the client stops the transfer as soon as the table directory is seen.
        Individual tables, as needed, are then loaded
        with HTTP/2 byterange requests.
        Individual glyph outlines are also requested
        with HTTP/2 byterange requests.
        Therefore, in this method, <em>only</em> the glyph outlines are subsetted,
        thus ensuring that all the other tables are preserved.
        Ths means that the download size for the processed font
        is the same as the original font, for all tables which do not contain glyph outlines.
      </p>

      <p>
        In addition, the font must be pre-processed:</p>

        <ul>
          <li>Composite glyphs are flattened into the resulting outlines
        </li>
        <li>The <span class="sfnt">CFF</span> table, if present, is desubroutinized,
        charstrings (glyph outlines) moved to the end of the table
      </li>
        <li>The <span class="sfnt">glyf</span> or <span class="sfnt">CFF</span>  table (whichever one is present) is moved to the end of the font
          (the <span class="sfnt">SVG</span> table, if present is not moved
          and thus, any glyphs there are always downloaded)
        </li>
      </ul>

      <p>
        This preprocessing need only happen once,
        so can be done by an authoring tool or a utility.
        (An experimental proof-of-concept utility to do this preprocessing
        is available [<a href="#ref-Streamable-Fonts">Streamable Fonts</a>]).
      </p>

      <p>
          The resulting preprocessed font is larger,
        <!-- how much larger -->
        but byterange streaming can be used to download portions of the glyph outline data.
        First a static subset of the entire font
        (but with <em>zero</em> glyph outlines)
        is downloaded.
        The client then requests glyph outliness as needed
        using standard HTTP byre range requests,
        which are supported on all common servers.
        The efficiency loss from this approach
        depends on the balance of glyph outline data to other font data.
        Efficiency is improved if glyphs are re-ordered in terms of statistical occurrence.
      </p>

      <p>
        This approach allows easier deployment,
        because any standard server can be used.
        There is no risk of accidentally breaking font rendering
        due to mis-subsetting complex tables.
        There is however no tuning for differing network conditions.
        Also, compared to WOFF2 which compresses redundant or duplicate data,
        there is no compression of redundant data between requests in this model.
      </p>
    </section>
  </section>

    <section>
      <h3 class="heading settled" data-level="2" id="cost"><span class="secno">4.3 </span><span class="content">Cost function</span><a class="self-link" href="#cost"></a></h3>
    <p>
      The impact of network delay was modelled as a <strong>cost function</strong>.
      This is not straightforward to model as there are two boundding factors:
    </p>

    <dl>
      <dt>Too slow</dt>
      <dd>Beyond a certain point, the user may give up and go to a different page.
        Or, beyond a certain maximum time <strong>T<sub>m</sub></strong>
        the browser may substitute a system font so that page rendering can occur.
        Delays beyond that point do not further impact the user experience.
        In this study, <strong>T<sub>m</sub></strong> was set to 3.5 seconds.
      </dd>
      <dt>Too fast</dt>
      <dd>Not that anything can really be too fast, but
        the inherent delays in HTML page and CSS stylesheet loading,
        and image loading, mean that further shortening the load time
        <strong>T<sub>z</sub></strong>
        for a font that already loads rapidly will not improve the user experience
        because it is no longer the limiting factor.
        <strong>T<sub>z</sub></strong> was set to 400 milliseconds.
      </dd>
    </dl>
    <p>Denoting the maximum cost as <strong>M</strong>, the cost at time <em>t</em>
    can be represented by a <a href="https://github.com/w3c/PFE-analysis/blob/master/analysis/cost.py">sigmoid function</a>,
    chosen to give a cost rising from 0 after <strong>T<sub>z</sub></strong>,
    approaching 1000 at <strong>T<sub>m</sub></strong>,
    and centered within that range.
    </p>
    <p><img src="images/cost-eqn.png" alt="cost equation" style="margin-left:auto; margin-right:auto; max-width:50vw"/>
    </p>

    <figure>
      <figcaption>The overall shape of the cost function is sigmoid</figcaption>
      <img src="../results/07-08-2020/cost.png" alt="graph of cost equation" style="margin-left:auto; margin-right:auto; max-width:60vw"/>
    </figure>

   </section>


    <section>
        <h3 class="heading settled" data-level="2" id="network"><span class="secno">4.4 </span><span class="content">Network type - slow 2G to fast broadband</span><a class="self-link" href="#network"></a></h3>

        <p>The type of network
          has a large impact on perceived performance
          (time from network request to first rendered text).
          Not only bandwidth but also latency,
          which can be substantial (ten seconds!) on slower mobile networks,
          must be considered.
        </p>
        <p>
          In this study each network type is represented by a <em>network model</em>.
          A network model is defined as
          the estimated round trip time,
          the upstream bandwidth,
          and the downstream bandwidth.
        </p>
        <p>
          The size of HTTP/2 request headers and responses
          (using HPACK) was based on
          observing request header sizes
          for sample requests
          to a fonts Content Distribution Network (CDN).
        </p>
        <p>
          The <a href="https://github.com/w3c/PFE-analysis/blob/master/analysis/network_models.py">network models</a>
          for mobile 2G, 3G, 4G, mobile WiFi, and Desktop (on a fast connection)
          were derived from browser reported connection speeds (from Chrome),
          across each connection type.
          For each connection type
          5 different speeds were provided,
          ranging from the slowest observed speeds
          to the fastest observed for that connection type.
        </p>

        <table  class="data">
          <caption>Network latencies (ms)</caption>
          <tr>
            <th> </th>
            <th>Slowest</th>
            <th>Slow</th>
            <th>Median</th>
            <th>Fast</th>
            <th>Fastest</th>
          </tr>
          <tr>
            <th>mobile 2G</th>
            <td>10,000</td>
            <td>4,500</td>
            <td>2,750</td>
            <td>1,500</td>
            <td>125</td>
          </tr>
          <tr>
            <th>mobile 3G</th>
            <td>2,750</td>
            <td>550</td>
            <td>300</td>
            <td>175</td>
            <td>115</td>
          </tr>
          <tr>
            <th>mobile 4G</th>
            <td>650</td>
            <td>225</td>
            <td>150</td>
            <td>110</td>
            <td>70</td>
          </tr>
          <tr>
            <th>mobile WiFi&nbsp;</th>
            <td>500</td>
            <td>170</td>
            <td>115</td>
            <td>65</td>
            <td>35</td>
          </tr>
          <tr>
            <th>Desktop</th>
            <td>350</td>
            <td>150</td>
            <td>80</td>
            <td>50</td>
            <td>20</td>
          </tr>
        </table>

        <table class="data">
          <caption>Network bandwidth (kB/s)</caption>
          <tr>
            <th> </th>
            <th>Slowest</th>
            <th>Slow</th>
            <th>Median</th>
            <th>Fast</th>
            <th>Fastest</th>
          </tr>
          <tr>
            <th>mobile 2G</th>
            <td>4</td>
            <td>6</td>
            <td>9</td>
            <td>19</td>
            <td>200</td>
          </tr>
          <tr>
            <th>mobile 3G</th>
            <td>13</td>
            <td>50</td>
            <td>156</td>
            <td>219</td>
            <td>750</td>
          </tr>
          <tr>
            <th>mobile 4G</th>
            <td>47</td>
            <td>181</td>
            <td>238</td>
            <td>750</td>
            <td>2,250</td>
          </tr>
          <tr>
            <th>mobile WiFi&nbsp;</th>
            <td>100</td>
            <td>200</td>
            <td>563</td>
            <td>1,250</td>
            <td>3,438</td>
          </tr>
          <tr>
            <th>Desktop</th>
            <td>125</td>
            <td>313</td>
            <td>938</td>
            <td>2,188</td>
            <td>7,500</td>
          </tr>
        </table>

        <p class="note">
          Note: In this study, download bandwidth was considered far more important
          than upload bandwidth (because requests are small and responses large).
          Therefore, even though asymmetric networks such as ADSL are common,
          the bandwidth in both directions was treated as the same.
        </p>

        <p>
          For the <strong>Patch and Subset</strong> model,
          a simple HTTP POST was used for the request,
          consisting of a binary protocol buffer (proto3)
          which identified the font, the characters needed, and the characters already downloaded.
          For the <strong>Glyph Byterange</strong> model,
          HTTP GET byterange requests were used.
          Reasonable defaults for request and response header size
          (35 bytes each)
          were used in the simulation.
        </p>

        <p>
          For the earlier tests,
          results were reported for each speed class in each network type.
          However this was found to be too cluttered for meaningful comparison
          and so the resuts for each network type
          were aggregated as a weighted average.
          Slowest and Fastest were weighted 5%,
          Slow and Fast weighted 20%,
          and Median weighted 50%.
        </p>
    </section>

    <section>
        <h3 class="heading settled" data-level="2" id="langtype"><span class="secno">4.5 </span><span class="content">Language type: small &amp; simple, complex shaping, large</span><a class="self-link" href="#langtype"></a></h3>

        <p>
          To better understand how progressive font enrichment
          performs for different scripts, the Web page corpus data
          and the corresponding fonts
          were divided
          into <a href="#langtype">three groups</a>
          based on the characteristics of those languages:</p>

      <ol>
        <li>Simple alphabetic languages: using Latin, Cyrillic, Greek and Thai scripts</li>
        <li>Languages which require glyph shaping: Arabic and Indic</li>
        <li>Languages with large character repertoires: Chinese, Japanese, and Korean</li>
      </ol>

      <p>The study evaluated performance for these three linguistic groupings separately.
        The groupings were selected by grouping together scripts that should have similar behaviour with respect to progressive font enrichment.
      </p>

      <section>
        <h4 class="heading settled" data-level="3" id="corpus"><span class="secno">4.5.1 </span><span class="content">Web corpus</span><a class="self-link" href="#corpus"></a></h4>

        <p>
          To simulate the sort of multiple-page browsing experience
          which would benefit from PFE,
          a corpus of Web page views was assembled for each language group.
          These were analyzed to yeild
          <strong>sequences of character requests</strong>
          which would generate font requests
          for the characters not previously encountered.
         </p>


       <p>
         The breakdown of languages within each linguistic category was as follows:
       </p>

       <figure>
         <figcaption>Breakdown of simple alphabetic languages</figcaption>
         <img src="../results/07-08-2020/latin.lang_breakdown.png" alt="" style="max-width: 90vw">
       </figure>

       <p>
        Due to the large number of sequences present in the simple alphabetic group,
        one out of 1000 of the sequences in the data set was randomly selected
        for use in the analysis.
        After sampling. this data set is composed of approximately 130,000 sequences.
        English predominates, at 50%.
        Using different sampling to increase the number of
        non-English sequences was considered,
        but it was decided to retain the observed language distribution of websites.
      </p>

       <figure>
        <figcaption>Breakdown of glyph-shaping languages</figcaption>
        <img src="../results/07-08-2020/arabic_indic.lang_breakdown.png" alt="" style="max-width: 90vw">
      </figure>

      <p>
        After sampling, the glyph-shaping data set
        is composed of approximately 6,500 sequences.
        Arabic languages, at 53%, predominate in this dataset.
      </p>

      <figure>
        <figcaption>Breakdown of CJK languages</figcaption>
        <img src="../results/07-08-2020/cjk.lang_breakdown.png" alt="" style="max-width: 90vw">
      </figure>

      <p>
        After sampling, the CJK dtatset contained approximately 6,000 sequences.
        Japanese predominates at 60%,
        with Traditional and Simplified Chinese totalling 35%.
      </p>

    </section>

    <section>
      <h4 class="heading settled" data-level="3" id="font-langtype"><span class="secno">4.5.2 </span><span class="content">Fonts by language type</span><a class="self-link" href="#font-langtype"></a></h4>

        <p>Fonts vary in size and complexity based on which of these language families they support.</p>

        <p>Fonts for alphabetic languages
          with small glyph repertoires
          and little to no shaping requirements
          are the smallest
          and, to date,
          the most sucessful in terms of Webfont usage.
          Many European languages fall into this category.
          The more recent adoption of
          glyph alternates,
          stylistic sets,
          and variable fonts
          has not significantly altered Webfont use for this category.
        </p>

        <p>
          The TrueType or OpenType fonts used for alphabetic languages had a median size of 17,660 bytes,
          with a spread from 15,784 bytes (5th percentile) to 184,152 bytes (95th percentile). The median size once WOFF2 compressed was 8,360 bytes. [<a href="ref-PFE-font-sizes">PFE Font Sizes</a>]
        </p>


        <p>
          Fonts for Indic languages, Arabic, and Farsi
          fall into a second category.
          The glyph repertoire is much larger than the character repertoire,
          because the scripts used have complex, context-dependent shaping requirements.
          Fonts which fail to support these features
          do not just provide "less beautiful" text,
          they provide unreadable text.
          Fonts in this category tend to use
          <!-- <span class="todo">which OT tables besides GPOS and GSUB</span> -->
          and to be easily broken by poor-quality font subsetting software.
          When correctly done, a static per-language subset is still fairly small.
        </p>

        <p>
          The TrueType or OpenType fonts used for glyph shaping languages had a median size of 93,588 bytes,
          with a spread from 15,784 bytes (5th percentile) to 459,600 bytes (95th percentile). The median size once WOFF2 compressed was 30,332 bytes. [<a href="ref-PFE-font-sizes">PFE Font Sizes</a>]
        </p>

        <p>
          Fonts for ideographic languages
          such as Chinese, Japanese and Korean
          have extremely large character and glyph repertoires,
          of the order of tens of thousands of glyphs.
          On the other hand, besides vertical and horizontal glyph variants,
          and "full-width" vs. "half-width" glyph variants for a few characters,
          the shaping requirements are low to none.
          Thus, the font size is almost entirely determined by the glyph outline data,
          and subsetting is primarily
          a case of partitioning the glyph outline data
          into small groups
          which are frequently used together.
        </p>

        <p>
          The TrueType or OpenType fonts used for CJK languages had a median size of 1,834,496 bytes,
          with a spread from 16,832 bytes (5th percentile) to 5,524,2080 bytes (95th percentile). The median size once WOFF2 compressed was 768,492 bytes. [<a href="ref-PFE-font-sizes">PFE Font Sizes</a>]
        </p>

        <p class="note">
          Note: because the preprocessor
          used to prepare fonts for the <strong>Glyph Byterange</strong>
          approach drops all hinting information,
          to make a fair comparison,
          the fonts used for the <strong>Patch and Subset</strong>
          approach also had hintng information removed.
          There is nothing in either approach
          which precludes sending hinting information;
          this was just a limitation of some of the software used in this analysis.
        </p>

        <p class="note">
          Note: Because the <a href="https://www.w3.org/TR/WOFF2/#table_format">additional table transforms in WOFF2</a>
          (and subsequent client-side table reconstitution)
          would have complicated the simulation,
          both <strong>Patch and Subset</strong> and
          <strong>Glyph Byterange</strong>
          simulated serving the initial font as  TrueType or Opentype font
          (over HTTP/2), with Brotli used as HTTP Content Transfer Encoding.
        </p>

    </section>

    <section>
        <h3 class="heading settled" data-level="2" id="codepredict"><span class="secno">4.6 </span><span class="content">Codepoint Prediction</span><a class="self-link" href="#codepredict"></a></h3>

        <p>
          Because making many small requests is costly,
          it could be beneficial to send additional codepoints
          besides the ones actually requested.
          The hope is that they will be needed later, when the user visits a different page.
          This is a tradeoff, potentially increasing total download size
          (if the codepoints end up not being used)
          but potentially decreasing the number of separate requests.
          This is particularly valuable on network connections with longer round trip times.
        </p>

        <p>
          Rather than sending random codepoints,
          it is best if the server tries to predict which unseen codepoints
          are statistically likely to occur in the future.
          This is called codepoint prediction.
        </p>

        <p>
          In this study, an index of the Web was analyzed
          to determine the frequency of occurrence
          (percentage of documents in the index which include that codepoint at least once)
          for each codepoint.
          The index was segmented by script
          (using the same script subsets
          as are used for unicode-range subsetting
          by Google Fonts
          [<a href="#ref-Google-scrpt-subsets">Google script subsets</a>]).
        </p>

        <p>
          Each client request contains the font to enrich,
          the set of codepoints already downloaded,
          and the set of codepoints to be added.
        </p>

        <p>
          The prediction algorithm in this study had two variables,
          which could be tuned to give different tradeoffs
          suitable for different network conditions:
          <strong>N</strong> is the number of predicted codepoints to add,
          and
          <strong>F</strong> is a minimum occurrence theshold.
          Codepoints which occur less frequently than <strong>F</strong>
          will not be sent (unless explicitly requested).
          The algorithm proceeded in four stages:
        </p>

        <ol>
          <li>Find all script subsets which intersect the set of codepoints the client wants to add</li>
          <li>Discard any of those script subsets which do not intersect the codepoint coverage of the font to be augmented</li>
          <li>Pick the top <strong>N</strong> codepoints by frequency which are
            <ul>
              <li>in the font to be augmented</li>
              <li>not in the set of codepoints the client has, or wants</li>
              <li>in any of the subsets matched in steps 1 and 2</li>
              <li>above frequency threshold <strong>F</strong></li>
            </ul>
          </li>
          <li>Return the requested codepoints,
            plus the predicted codepoints.</li>
        </ol>

        <p>
          The simulation was run with two or three different values for
          <strong>N</strong> and <strong>F</strong>,
          for each <a href="#langtype">language type</a>:</p>

          <table  class="data" id="pred-table">
            <tr>
              <th>Language Type</th>
              <th>N (Max codepoints)</th>
              <th>F (Frequency Threshold)</th>
            </tr>
            <tr>
              <td rowspan="2">Latin, Greek Cyrillic, Thai</td>
              <td>87</td>
              <td>0.005</td>
            </tr>
            <tr>
              <td>37</td>
              <td>0.005</td>
            </tr>
            <tr>
              <td  rowspan="2">Arabic + Indic</td>
              <td>109</td>
              <td>0.005</td>
            </tr>
            <tr>
              <td>55</td>
              <td>0.00615</td>
            </tr>
            <tr>
              <td rowspan="3">Chinese, Japanese, Korean</td>
              <td>1500</td>
              <td>0.005</td>
            </tr>
            <tr>
              <td>941</td>
              <td>0.062</td>
            </tr>
            <tr>
              <td>24</td>
              <td>0.999</td>
            </tr>
          </table>


        <p>
          The results [<a href="#ref-codepoint-prediction">Codepoint Prediction</a>]
          are summarized <a href="#analysis-prediction">later in this report</a>.
        </p>
        <!--
Progressive Font Enrichment: Codepoint Prediction Results
(patch only)
https://docs.google.com/document/d/1u-05ztF9MqftHbMKB_KiqeUhZKiXNFE4TRSUWFAPXsk/edit

Codepoint prediction, that is adding extra non-requested codepoints to a font augmentation response was tested with the progressive font enrichment simulations to see if it could improve performance and close the gaps where progressive font enrichment performed worse than existing transfer methods.

The result of the simulations showed that for all three script categories using codepoint prediction was able to lower costs enough to tie or beat existing transfer methods for all connection types other than Mobile 2G and the slowest variant of Mobile 3G. This comes at the cost of sending more bytes, but still sends less bytes than existing transfer methods.

CJK scripts benefited the least from prediction. Arabic, Indic, Latin, Cyrllic, Greek, and Thai saw more improvements.  For those scripts prediction closed the performance gap between existing font transfer methods for many connection types.

Prediction was not beneficial in all cases. For some script and network conditions combinations it increased overall cost. If prediction is to be used it should be selectively enabled based on the script and client network capabilities.


        -->

    </section>
<!--
  I'm sure we studied this but I can't find any report on it, so commenting out for now.

    <section>
        <h3 class="heading settled" data-level="2" id="group"><span class="secno">4.7 </span><span class="content">Byterange subsetting: glyph grouping</span><a class="self-link" href="#group"></a></h3>

        <p class="todo">todo</p>

    </section> -->



    <section>
        <h3 class="heading settled" data-level="2" id="framework"><span class="secno">4.7 </span><span class="content">Simulation and analysis framework</span><a class="self-link" href="#framework"></a></h3>

        <p class="todo">todo</p>

    </section>

    <section>
        <h3 class="heading settled" data-level="2" id="oos"><span class="secno">4.9 </span><span class="content">Out of scope</span><a class="self-link" href="#oos"></a></h3>

        <p>
            Because this was a pre-standarization experiment,
            details of wire protocols
            (which would certainly be needed for an interoperable standard)
            were not comparatively explored at this stage.

        </p>

    </section>
    </section>

    <section>
    <h2 class="heading settled" data-level="1" id="analysis"><span class="secno">5. </span><span class="content">Analysis</span><a class="self-link" href="#analysis"></a></h2>

    <!--

    -->
    <p class="todo">todo</p>

    </section>

    <section>
        <h2 class="heading settled" data-level="1" id="conclusions"><span class="secno">6. </span><span class="content">Conclusions</span><a class="self-link" href="#conclusions"></a></h2>

        <!--
          minimal set, not too complex
          clearly lead to next steps

          cjk good for range and pathch, as long as 4G connection or above

          table, network model ( 3G below, 4G abve. high and low latency is the main effect)
          and CJK vs non-CJK language
          conclusion in each cell

          myles wants the full matrix first. color code.

          deplyability conclusion as well as perf.

          Myles, proof of concept tool for making the optimised streamable font. Don't *need* to collect the glyphs

          study: charstrings at end of CFF table

          study: binary patch generation from brotli and client patching is already deployed in servers and clients,
          brotli library has the function to call (?true?)
          cost is therefore less.
          patch benefits from brotli compression dictionary
          brotli in FF, Chrome, Edge but not Safari (it goes to CoreText) browsers now (WOFF2 and HTTP support)
          Safari would need to do it in webkit separately api boundary. Marginaly higher.

          analysis: caches also need to understand the protocol
          POST bypasses caches
          Final one needs to work with caches

          Garret code can go into an Apache module
          not yet integrated

        -->
        <p class="todo">todo</p>

        </section>

    </section>























   <!-- <section>
    <h2 class="heading settled" data-level="1" id="intro"><span class="secno">1. </span><span class="content">Introduction</span><a class="self-link" href="#intro"></a></h2>
    <p></p>
   </section> -->


  </main>

  <section>
    <h2 class="heading settled" data-level="1" id="references"><span class="secno">A. </span><span class="content">References</span><a class="self-link" href="#references"></a></h2>

    <!--
Harfbuzz Tech Talk:
https://docs.google.com/presentation/d/1RMkpikAUmdIXaz3eEDYFETWfAwnT0Vw8_oC8Ait5xqs/edit?usp=sharing

Webpage Corpus msg
https://lists.w3.org/Archives/Public/public-webfonts-wg/2019Oct/0011.html
Re: Webpage Corpus
https://lists.w3.org/Archives/Public/public-webfonts-wg/2019Nov/0003.html

Analysis Framework Updates msg
https://lists.w3.org/Archives/Public/public-webfonts-wg/2019Dec/0003.html

Details of our Unicode Range Blocking Algorithm
https://lists.w3.org/Archives/Public/public-webfonts-wg/2020May/0007.html

Progressive Font Enrichment Simulation Results (May 12th, 2020 Data Set)
https://docs.google.com/document/d/1aShjR0-UVoQcu1R9GGPF_Qa3bViOdqYVlk7HM07IdGU/edit#

Progressive Font Enrichment: Codepoint Prediction Results
https://docs.google.com/document/d/1u-05ztF9MqftHbMKB_KiqeUhZKiXNFE4TRSUWFAPXsk/edit#heading=h.l2if29tj434

Subset and Patch Progressive Font Enrichment Protocol Design
https://docs.google.com/document/d/1DJ6VkUEZS2kvYZemIoX4fjCgqFXAtlRjpMlkOvblSts/edit#

WOFF 2.0, the inside scoop
https://www.w3.org/blog/2018/03/woff-2-0-the-inside-scoop/

Happy Birthday Web Fonts!
https://www.w3.org/blog/2020/07/happy-birthday-web-fonts/

How does web font usage vary by country?
https://discuss.httparchive.org/t/how-does-web-font-usage-vary-by-country/1649

    -->
    <dl>

        <dt id="cl-vs-la">CLOSURE</dt>
        <dd><cite><a href="https://docs.google.com/presentation/d/1qczAiExsuxhtm-0WSlZ0eSiHVOuuq1agTKZTU-26n5k/edit?usp=sharing">Closure vs Layout
            </a>,
          Roderick Sheeter (author)</cite>
      </dd>


        <dt id="ref-CSS2">CSS2</dt>
        <dd>
            <cite><a href="https://www.w3.org/TR/1998/REC-CSS2-19980512/">Cascading
                Style Sheets, level 2</a>,
                Bert Bos,
                Håkon Wium Lie,
                Chris Lilley,
                Ian Jacobs (editors).
            </cite>
            W3C Recommendation 12 May 1998<br>
            URL: <a href="https://www.w3.org/TR/1998/REC-CSS2-19980512/">https://www.w3.org/TR/1998/REC-CSS2-19980512/</a>
        </dd>

        <dt id="ref-CSS21-fpwd">CSS2.1 FPWD</dt>
        <dd>
            <cite><a href="https://www.w3.org/TR/2002/WD-CSS21-20020802/">Cascading
                Style Sheets Level 2 Revision 1 (CSS 2.1) Specification</a>,
                Bert Bos,
                Tantek Çelik,
                Ian Hickson,
                Håkon Wium Lie (editors).
            </cite>
            W3C First Public Working Draft 2 August 2002<br>
            URL: <a href="https://www.w3.org/TR/2002/WD-CSS21-20020802/">https://www.w3.org/TR/2002/WD-CSS21-20020802/</a>
        </dd>

        <dt id="ref-CSS21">CSS2.1</dt>
        <dd>
            <cite><a href="https://www.w3.org/TR/2011/REC-CSS2-20110607/">Cascading
                Style Sheets Level 2 Revision 1 (CSS 2.1) Specification</a>,
                Bert Bos,
                Tantek Çelik,
                Ian Hickson,
                Håkon Wium Lie (editors).
            </cite>
            W3C Recommendation 07 June 2011<br>
            URL: <a href="https://www.w3.org/TR/2011/REC-CSS2-20110607/">https://www.w3.org/TR/2011/REC-CSS2-20110607/</a>
        </dd>

      <dt id="ref-css3-webfonts">CSS3 WebFonts</dt>
      <dd><cite><a href="https://www.w3.org/TR/2002/WD-css3-webfonts-20020802/">CSS3 module: Web Fonts</a>,
        Michel Suignard,
        Chris Lilley (editors). </cite>
      W3C Working Draft 2 August 2002<br>
      URL: <a href="https://www.w3.org/TR/2002/WD-css3-webfonts-20020802/">https://www.w3.org/TR/2002/WD-css3-webfonts-20020802/</a>
    </dd>

      <dt id="ref-css-fonts-3-fpwd">CSS Fonts 3 FPWD</dt>
      <dd><cite><a href="https://www.w3.org/TR/2011/WD-css3-fonts-20111004/">CSS Fonts Module Level 3</a>,
        John Daggett (editor).
      </cite>
      W3C First Working Draft, 4 October 2011<br>
      URL: <a href="https://www.w3.org/TR/2011/WD-css3-fonts-20111004/">https://www.w3.org/TR/2011/WD-css3-fonts-20111004/</a>
    </dd>

    <dt id="ref-css-fonts-3">CSS Fonts 3</dt>
      <dd><cite><a href="https://www.w3.org/TR/css-fonts-3/">CSS Fonts Module Level 3</a>,
        John Daggett,
        Myles Maxfield,
        Chris Lilley (editors).
      </cite>
      W3C Recommendation 20 September 2018<br>
      URL: <a href="https://www.w3.org/TR/css-fonts-3/">https://www.w3.org/TR/css-fonts-3/</a>
    </dd>

      <dt id="ref-Indic-Intro">Indic-Intro</dt>
      <dd><cite><a href="">An Introduction to Indic Scripts</a>,
        Richard Ishida
      </cite><br>
      URL (html): <a href="https://www.w3.org/2002/Talks/09-ri-indic/indic-paper.html">https://www.w3.org/2002/Talks/09-ri-indic/indic-paper.html</a><br>
      URL (pdf): <a href="http://www.w3.org/2002/Talks/09-ri-indic/indic-paper.pdf">http://www.w3.org/2002/Talks/09-ri-indic/indic-paper.pdf</a>
    </dd>

      <dt id="ref-IndicLR">IndicLR</dt>
      <dd><cite><a href="https://www.w3.org/TR/ilreq/#h_indian_language_complexities">Indic
          Layout Requirements</a>,
          Swaran Lata,
          Somnath Chandra,
          Prashant Verma (editors).
        </cite>
        W3C Working Draft 29 May 2020<br>
        URL: <a href="https://www.w3.org/TR/ilreq/#h_indian_language_complexities">https://www.w3.org/TR/ilreq/</a>
      </dd>

      <dt id="ref-OFF">OFF</dt>
      <dd><cite><a href="">ISO/IEC 14496-22:2019
        Information technology — Coding of audio-visual objects — Part 22: Open Font Format</a>,
        ISO/IEC JTC 1/SC 29
        Coding of audio, picture, multimedia and hypermedia information
      </cite>
      International Standard, January 2019<br>
      URL: <a href="https://standards.iso.org/ittf/PubliclyAvailableStandards/c074461_ISO_IEC_14496-22_2019.zip">https://standards.iso.org/ittf/PubliclyAvailableStandards/c074461_ISO_IEC_14496-22_2019.zip</a>
    </dd>

    <dt id="ref-OpenType">OpenType</dt>
    <dd><cite><a href="https://docs.microsoft.com/en-us/typography/opentype/spec/">OpenType® specification</a>,
    Microsoft.
    </cite>
    URL: <a href="https://docs.microsoft.com/en-us/typography/opentype/spec/">https://docs.microsoft.com/en-us/typography/opentype/spec/</a>
  </dd>

    <dt id="ref-patch-subset-design">Patch and Subset Design</dt>
    <dd><cite><a href="https://docs.google.com/document/d/1DJ6VkUEZS2kvYZemIoX4fjCgqFXAtlRjpMlkOvblSts/edit">Subset and Patch Progressive Font Enrichment Protocol Design</a>,
      Garret Rieger (author).
    </cite>
    7 August 2019.<br>
    URL: <a href="https://docs.google.com/document/d/1DJ6VkUEZS2kvYZemIoX4fjCgqFXAtlRjpMlkOvblSts/edit#">https://docs.google.com/document/d/1DJ6VkUEZS2kvYZemIoX4fjCgqFXAtlRjpMlkOvblSts/edit#</a>
  </dd>

  <dt id="ref-PFErepo">PFE-repo</dt>
  <dd><cite><a href="https://github.com/w3c/PFE-analysis">Progressive Font Enrichment (PFE) GitHub repository</a></cite>
  </dd>

  <dt id="ref-PFE-font-sizes">PFE Font Sizes</dt>
  <dd><cite><a href="https://docs.google.com/spreadsheets/d/1KJvxQxeBtGNYmcSPFT4CAFEQU2hDBN2XwFIyqf8_ISY/edit#gid=0">Sizes of fonts used in the PFE simulation</a>,
    Garret Rieger (author)
  </cite>
  URL: <a href="https://docs.google.com/spreadsheets/d/1KJvxQxeBtGNYmcSPFT4CAFEQU2hDBN2XwFIyqf8_ISY/edit#gid=0">https://docs.google.com/spreadsheets/d/1KJvxQxeBtGNYmcSPFT4CAFEQU2hDBN2XwFIyqf8_ISY/edit#gid=0</a>
</dd>

  <dt id="ref-Sheeter-BigQuery">Sheeter BigQuery</dt>
  <dd><cite>Analysis of <a href="https://github.com/HTTPArchive/almanac.httparchive.org/issues/902#issuecomment-662689190">HTTP Archive Web Almanac results</a>,
    Roderick Sheeter
  </cite>
  URL: <a href="https://docs.google.com/spreadsheets/d/1N5oaO5Sgod70VSplx521E7lkiPww97cOxd7iBD7GLkc/edit#gid=464027685">https://docs.google.com/spreadsheets/d/1N5oaO5Sgod70VSplx521E7lkiPww97cOxd7iBD7GLkc/edit#gid=464027685</a>
  </dd>

    <dt id="ref-Streamable-Fonts">Streamable Fonts</dt>
    <dd><cite><a href="https://github.com/litherum/StreamableFonts">Streamable
      Fonts GitHub repo</a>,
      Myles Maxfield</cite>
      URL: <a href="https://github.com/litherum/StreamableFonts">https://github.com/litherum/StreamableFonts</a>
  </dd>

      <dt id="ref-SVG1">SVG1</dt>
      <dd>
          <cite><a href="https://www.w3.org/TR/2001/REC-SVG-20010904/">Scalable
              Vector Graphics (SVG) 1.0 Specification</a>,
              Jon Ferraiolo (editor).
          </cite>
          W3C Recommendation 04 September 2001<br>
          URL: <a href="https://www.w3.org/TR/2001/REC-SVG-20010904/">https://www.w3.org/TR/2001/REC-SVG-20010904/</a>
      </dd>

      <dt id="ref-TrueType">TrueType</dt>
      <dd><cite><a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/">TrueType Reference Manual</a>,
      Apple Inc.</cite>
      URL: <a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/">https://developer.apple.com/fonts/TrueType-Reference-Manual/</a>
      </dd>

      <dt id="ref-Web-Almanac-2019-Fonts">Web Almanac 2019: Fonts</dt>
      <dd><cite><a href="https://almanac.httparchive.org/en/2019/fonts">Web Almanac 2019, Part 1 Chapter 6: Fonts</a>,
      Zach Letherman <em>et. al.</em>
      HTTP Archive, 2019</cite>
      URL: <a href="https://almanac.httparchive.org/en/2019/fonts">https://almanac.httparchive.org/en/2019/fonts</a>
    </dd>

        <dt id="ref-webfonts">WebFonts</dt>
        <dd><cite><a href="https://www.w3.org/TR/WD-font-970721">Web Fonts</a>,
        Chris Lilley (editor).</cite>  W3C Working Draft, 21 July 1997<br>
        URL: <a href="https://www.w3.org/TR/WD-font-970721">https://www.w3.org/TR/WD-font-970721</a>
        </dd>

        <dt id="ref-WOFF1">WOFF1</dt>
        <dd><cite><a href="https://www.w3.org/TR/2012/REC-WOFF-20121213/">WOFF File Format 1.0</a>,
            Jonathan Kew, Tal Leming, Erik van Blokland (editors).
        </cite>
        W3C Recommendation 13 December 2012<br>
        URL: <a href="https://www.w3.org/TR/2012/REC-WOFF-20121213/">https://www.w3.org/TR/2012/REC-WOFF-20121213/</a>
        </dd>

        <dt id="ref-WOFF2">WOFF2</dt>
        <dd><cite><a href="https://www.w3.org/TR/2018/REC-WOFF2-20180301/">WOFF
            File Format 2.0 </a>,
            Vladimir Levantovsky,
            Raph Levien (editors).
        </cite>
        W3C Recommendation 01 March 2018<br>
        URL: <a href="https://www.w3.org/TR/2018/REC-WOFF2-20180301/">https://www.w3.org/TR/2018/REC-WOFF2-20180301/</a>
        </dd>

        <dt id="ref-WOFF2-ER">WOFF2ER</dt>
        <dd><cite><a href="https://www.w3.org/TR/WOFF20ER/">WOFF 2.0
            Evaluation Report</a>,
            Chris Lilley (editor)
        </cite>
        W3C Working Group Note, 15 March 2016<br>
        URL: <a href="https://www.w3.org/TR/WOFF20ER/">https://www.w3.org/TR/WOFF20ER/</a>
    </dd>

        <dt id="ref-UNICODE-RANGE">UNICODE-RANGE</dt>
        <dd><cite><a href="https://www.w3.org/TR/css-fonts-4/#unicode-range-desc">Character
            range: the unicode-range descriptor</a></cite>. In
        <cite><a href="https://www.w3.org/TR/css-fonts-4/">CSS
            Fonts Module Level 4</a>,
            John Daggett,
            Myles C. Maxfield,
            Chris Lilley (editors).
        </cite>
        W3C Working Draft, 13 November 2019 <br>
        URL: <a href="https://www.w3.org/TR/css-fonts-4/#unicode-range-desc">https://www.w3.org/TR/css-fonts-4/#unicode-range-desc</a>
        </dd>

    </dl>
   </section>

  <script>
    (function() {
      "use strict";
      var collapseSidebarText = '<span aria-hidden="true">←</span> '
                              + '<span>Collapse Sidebar</span>';
      var expandSidebarText   = '<span aria-hidden="true">→</span> '
                              + '<span>Pop Out Sidebar</span>';
      var tocJumpText         = '<span aria-hidden="true">↑</span> '
                              + '<span>Jump to Table of Contents</span>';

      var sidebarMedia = window.matchMedia('screen and (min-width: 78em)');
      var autoToggle   = function(e){ toggleSidebar(e.matches) };
      if(sidebarMedia.addListener) {
        sidebarMedia.addListener(autoToggle);
      }

      function toggleSidebar(on) {
        if (on == undefined) {
          on = !document.body.classList.contains('toc-sidebar');
        }

        /* Don’t scroll to compensate for the ToC if we’re above it already. */
        var headY = 0;
        var head = document.querySelector('.head');
        if (head) {
          // terrible approx of "top of ToC"
          headY += head.offsetTop + head.offsetHeight;
        }
        var skipScroll = window.scrollY < headY;

        var toggle = document.getElementById('toc-toggle');
        var tocNav = document.getElementById('toc');
        if (on) {
          var tocHeight = tocNav.offsetHeight;
          document.body.classList.add('toc-sidebar');
          document.body.classList.remove('toc-inline');
          toggle.innerHTML = collapseSidebarText;
          if (!skipScroll) {
            window.scrollBy(0, 0 - tocHeight);
          }
          tocNav.focus();
          sidebarMedia.addListener(autoToggle); // auto-collapse when out of room
        }
        else {
          document.body.classList.add('toc-inline');
          document.body.classList.remove('toc-sidebar');
          toggle.innerHTML = expandSidebarText;
          if (!skipScroll) {
            window.scrollBy(0, tocNav.offsetHeight);
          }
          if (toggle.matches(':hover')) {
            /* Unfocus button when not using keyboard navigation,
               because I don’t know where else to send the focus. */
            toggle.blur();
          }
        }
      }

      function createSidebarToggle() {
        /* Create the sidebar toggle in JS; it shouldn’t exist when JS is off. */
        var toggle = document.createElement('a');
          /* This should probably be a button, but appearance isn’t standards-track.*/
        toggle.id = 'toc-toggle';
        toggle.class = 'toc-toggle';
        toggle.href = '#toc';
        toggle.innerHTML = collapseSidebarText;

        sidebarMedia.addListener(autoToggle);
        var toggler = function(e) {
          e.preventDefault();
          sidebarMedia.removeListener(autoToggle); // persist explicit off states
          toggleSidebar();
          return false;
        }
        toggle.addEventListener('click', toggler, false);


        /* Get <nav id=toc-nav>, or make it if we don’t have one. */
        var tocNav = document.getElementById('toc-nav');
        if (!tocNav) {
          tocNav = document.createElement('p');
          tocNav.id = 'toc-nav';
          /* Prepend for better keyboard navigation */
          document.body.insertBefore(tocNav, document.body.firstChild);
        }
        /* While we’re at it, make sure we have a Jump to Toc link. */
        var tocJump = document.getElementById('toc-jump');
        if (!tocJump) {
          tocJump = document.createElement('a');
          tocJump.id = 'toc-jump';
          tocJump.href = '#toc';
          tocJump.innerHTML = tocJumpText;
          tocNav.appendChild(tocJump);
        }

        tocNav.appendChild(toggle);
      }

      var toc = document.getElementById('toc');
      if (toc) {
        createSidebarToggle();
        toggleSidebar(sidebarMedia.matches);

        /* If the sidebar has been manually opened and is currently overlaying the text
           (window too small for the MQ to add the margin to body),
           then auto-close the sidebar once you click on something in there. */
        toc.addEventListener('click', function(e) {
          if(e.target.tagName.toLowerCase() == "a" && document.body.classList.contains('toc-sidebar') && !sidebarMedia.matches) {
            toggleSidebar(false);
          }
        }, false);
      }
      else {
        console.warn("Can’t find Table of Contents. Please use <nav id='toc'> around the ToC.");
      }

      /* Wrap tables in case they overflow */
      var tables = document.querySelectorAll(':not(.overlarge) > table.data, :not(.overlarge) > table.index');
      var numTables = tables.length;
      for (var i = 0; i < numTables; i++) {
        var table = tables[i];
        var wrapper = document.createElement('div');
        wrapper.className = 'overlarge';
        table.parentNode.insertBefore(wrapper, table);
        wrapper.appendChild(table);
      }

    })();
    </script>
    <script src="https://www.w3.org/scripts/TR/2016/fixup.js"></script>
 </body>
 </html>